<!DOCTYPE html><!--UE_zlTBY9TySNjoJB9Enp--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/url-notes/_next/static/css/f03c873af434c7c6.css" data-precedence="next"/><link rel="stylesheet" href="/url-notes/_next/static/css/0e5ea1ea0183b412.css" data-precedence="next"/><link rel="stylesheet" href="/url-notes/_next/static/css/7190d9c623ab1fe0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/url-notes/_next/static/chunks/webpack-54d9d4b2aa649176.js"/><script src="/url-notes/_next/static/chunks/4bd1b696-cf72ae8a39fa05aa.js" async=""></script><script src="/url-notes/_next/static/chunks/964-a29425d4972030f1.js" async=""></script><script src="/url-notes/_next/static/chunks/main-app-e4d4697bcd6cfe75.js" async=""></script><script src="/url-notes/_next/static/chunks/874-437a265a67d6cfee.js" async=""></script><script src="/url-notes/_next/static/chunks/app/all/%5BpageIndex%5D/page-680db69597409d20.js" async=""></script><title>url-notes | all | page 2 of 16</title><link rel="icon" href="/url-notes/favicon.ico" type="image/x-icon" sizes="256x256"/><script src="/url-notes/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><div class="page_Page__nS49m"><div class="Header_Header__VDN4T"><div class="Header_item__PWJos"><a href="/url-notes">url-notes</a></div><div class="Header_separator__zF22U">|</div><div class="Header_item__PWJos"><a href="/url-notes/all/0">all</a></div><div class="Header_separator__zF22U">|</div><div class="Header_item__PWJos"><span>page <!-- -->2<!-- --> of <!-- -->16</span></div></div><div class="page_content___i7Ut"><div class="page_previews__BuBMS"><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://arxiv.org/pdf/2506.18777">Programming by Backprop: LLMs Acquire Reusable Algorithmic Abstractions During Code Training</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Artificial%20Intelligence">Artificial Intelligence</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Computation%20and%20Language">Computation and Language</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Machine%20Learning">Machine Learning</a></div><div class="ArticlePreview_summary__Zyb4E"><p>Training large language models (LLMs) on source code significantly enhances their general-purpose reasoning abilities, but the mechanisms underlying this generalisation are poorly understood. In this paper, we propose Programming by Backprop (PBB) as a potential driver of this effect - teaching a model to evaluate a program for inputs by training on its source code alone, without ever seeing I/O examples. To explore this idea, we finetune LLMs on two sets of programs representing simple maths problems and algorithms: one with source code and I/O examples (w/ IO), the other with source code only (w/o IO). We find evidence that LLMs have some ability to evaluate w/o IO programs for inputs in a range of experimental settings, and make several observations. Firstly, PBB works significantly better when programs are provided as code rather than semantically equivalent language descriptions. Secondly, LLMs can produce outputs for w/o IO programs directly, by implicitly evaluating the program within the forward pass, and more reliably when stepping through the program in-context via chain-of-thought. We further show that PBB leads to more robust evaluation of programs across inputs than training on I/O pairs drawn from a distribution that mirrors naturally occurring data. Our findings suggest a mechanism for enhanced reasoning through code training: it allows LLMs to internalise reusable algorithmic abstractions. Significant scope remains for future work to enable LLMs to more effectively learn from symbolic procedures, and progress in this direction opens other avenues like model alignment by training on formal constitutional principles.</p></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://arxiv.org/pdf/2506.17871">How Alignment Shrinks the Generative Horizon</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag"></a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Computation%20and%20Language">Computation and Language</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Artificial%20Intelligence">Artificial Intelligence</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Machine%20Learning">Machine Learning</a></div><div class="ArticlePreview_summary__Zyb4E"><p>Despite their impressive capabilities, aligned large language models (LLMs) often generate outputs that lack diversity. What drives this stability in the generation? We investigate this phenomenon through the lens of probability concentration in the model&#x27;s output distribution. To quantify this concentration, we introduce the Branching Factor (BF) -- a token-invariant measure of the effective number of plausible next steps during generation. Our empirical analysis reveals two key findings: (1) BF often decreases as generation progresses, suggesting that LLMs become more predictable as they generate. (2) alignment tuning substantially sharpens the model&#x27;s output distribution from the outset, reducing BF by nearly an order of magnitude (e.g., from 12 to 1.2) relative to base models. This stark reduction helps explain why aligned models often appear less sensitive to decoding strategies. Building on this insight, we find this stability has surprising implications for complex reasoning. Aligned Chain-of-Thought (CoT) models (e.g., DeepSeek-distilled models), for instance, leverage this effect; by generating longer reasoning chains, they push generation into later, more deterministic (lower BF) stages, resulting in more stable outputs. We hypothesize that alignment tuning does not fundamentally change a model&#x27;s behavior, but instead steers it toward stylistic tokens (e.g., &quot;Sure&quot;) that unlock low-entropy trajectories already present in the base model. This view is supported by nudging experiments, which show that prompting base models with such tokens can similarly reduce BF. Together, our findings establish BF as a powerful diagnostic for understanding and controlling LLM outputs - clarifying how alignment reduces variability, how CoT promotes stable generations, and how base models can be steered away from diversity.</p></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://arxiv.org/pdf/2506.21521">Potemkin Understanding in Large Language Models</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Computation%20and%20Language">Computation and Language</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Artificial%20Intelligence">Artificial Intelligence</a></div><div class="ArticlePreview_summary__Zyb4E"><p>Large language models (LLMs) are regularly evaluated using benchmark datasets. But what justifies making inferences about an LLM&#x27;s capabilities based on its answers to a curated set of questions? This paper first introduces a formal framework to address this question. The key is to note that the benchmarks used to test LLMs -- such as AP exams -- are also those used to test people. However, this raises an implication: these benchmarks are only valid tests if LLMs misunderstand concepts in ways that mirror human misunderstandings. Otherwise, success on benchmarks only demonstrates potemkin understanding: the illusion of understanding driven by answers irreconcilable with how any human would interpret a concept. We present two procedures for quantifying the existence of potemkins: one using a specially designed benchmark in three domains, the other using a general procedure that provides a lower-bound on their prevalence. We find that potemkins are ubiquitous across models, tasks, and domains. We also find that these failures reflect not just incorrect understanding, but deeper internal incoherence in concept representations.</p></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://download.ssrn.com/2025/6/30/4440242.pdf?response-content-disposition=attachment%3B%20filename%3Dssrn-4440242.pdf&amp;X-Amz-Security-Token=IQoJb3JpZ2luX2VjENb%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIQDmvD0kwhxUvwfI51pkPe7LHJvlbunkSaSJ%2F%2FWUHoHLxwIgKvlIsW8iuAAP7s8oth%2F9YaKIKpRZ81hCBzCyI8YDF5oqxQUIz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAEGgwzMDg0NzUzMDEyNTciDPFDIhL%2BP88i2OXZ6SqZBefQZOwOYYLdg%2BqExabceAZ%2BrERHWnxBuYo%2BE3mBpdQ5F230f6aZ0YPQPQLAlDLggStpWurCRPjzdUpiah95RWY5%2Fho%2B%2BIJMQt%2BXlP2zJ0tH%2Bjc8L44sVb5xro0WdeoEbn9kv1HEEgPlyJYK9VnuSWakRRvq2rYBQF9GGYtOSNRKqubOHX3sn0Otqt0i4xN5FuayIg0CPeZtJ2ZgN%2FEH%2FDw6oir%2BvSvn%2FtOXrpYNe74yps2euHd9iiv21zZRIGlGwmKnrd%2F5lsjBUoLnOSd9VAa%2BqKrYp9ivQfcCB7Oqe9Rj4iLjh8TeVCyRqkXwBxbOOhxW8gomEJOcjOJpiTOeNooyzLgR7FZqo2h8ia6aVyhHQPTDvCQgtLLc%2FYQnd%2FQ9qZWwx2%2FbXqeXsNI5Or2qcgPy8Ul4%2F%2FeuLHbFsLA6FnY%2Fz5HbC%2BNoQP3SV3od4tYKPESNObQOMKixm7iq5TIdK1OzaeQhlSpGdFs7GWwiAWqXNDHVVFbdXLDczvSPpEaubfmUUhLiZaZA05HLMpMBrsDXgPfjVxwikIyC20x1NfE2G6diCN5zCaqR5l5Jh4lzKXTOKDZcs8iJs3I4mjCKmRn3BqSuWlaSI4K049EVQvifWBF8Oz42Yub0UXIbns659tipXWgnpe2t9dkVKEzRt4ENmyOi%2FaUHPxeQkigTmXHR0Cmb%2FYagZpfp5knBLBXlCjZxy3OlLDs8qZmvXreW4cBEts7UNy8IQLeuoxBYkr4nbNreSYRpTjw4tcG9zPmUUzuRVSt6VF07W5KJ1jQqTI4aJ4wtmWSgMFopPVGiyduaToM7%2FBxMY5gpV2ZsByt%2BJCObeZrUyRfq2HwHoWC5wGMiOjtsYe%2Bmetmp890mAOxL6VJowA%2Bl9Kh%2FMOnqjcMGOrEB18AnWgBDmlKkSscFIxJOL33ixrSai7YAjhHXpoVSUh3B0Z%2BMO2iO4XxEAzuzYhL9J%2BovhoVJ9GaFJdmMOqrxN1CRHitVibPr0mE0wZyNGqpu%2FjWOg6wvjLuET7Wxt7jxHMzmdpPEO26pBemUMHTSjbGtrC7Asc7wbAusIZ%2Fcuqy8B6MgLkiLi1QOIjBHzY7Vs6p2nu5u%2BjF4%2Fld1vyCVhsoH6J5EoMRRyixpRF4qv3T0&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Date=20250701T054517Z&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Expires=300&amp;X-Amz-Credential=ASIAUPUUPRWE7AM5UVQA%2F20250701%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Signature=50a47418d1bede25e5f619afb7a74d57c0d0600407a48e401744a96f24f59ed8&amp;abstractId=4440242">Cancel Culture</a></div><div class="ArticlePreview_summary__Zyb4E">&lt;div&gt;
 &lt;div&gt;
  Public controversies over employee speech where individuals face backlash for expressing views deemed controversial, &lt;span&gt;unpopular, or mis</div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://yosefk.com/blog/llms-arent-world-models.htmlhttps://arxiv.org/pdf/2505.17117">From Tokens to Thoughts: How LLMs and Humans Trade Compression for Meaning</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Computation%20and%20Language">Computation and Language</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Artificial%20Intelligence">Artificial Intelligence</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Information%20Theory">Information Theory</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/Information%20Theory">Information Theory</a></div><div class="ArticlePreview_summary__Zyb4E"><p>Humans organize knowledge into compact categories through semantic compression by mapping diverse instances to abstract representations while preserving meaning (e.g., robin and blue jay are both birds; most birds can fly). These concepts reflect a trade-off between expressive fidelity and representational simplicity. Large Language Models (LLMs) demonstrate remarkable linguistic abilities, yet whether their internal representations strike a human-like trade-off between compression and semantic fidelity is unclear. We introduce a novel information-theoretic framework, drawing from Rate-Distortion Theory and the Information Bottleneck principle, to quantitatively compare these strategies. Analyzing token embeddings from a diverse suite of LLMs against seminal human categorization benchmarks, we uncover key divergences. While LLMs form broad conceptual categories that align with human judgment, they struggle to capture the fine-grained semantic distinctions crucial for human understanding. More fundamentally, LLMs demonstrate a strong bias towards aggressive statistical compression, whereas human conceptual systems appear to prioritize adaptive nuance and contextual richness, even if this results in lower compressional efficiency by our measures. These findings illuminate critical differences between current AI and human cognitive architectures, guiding pathways toward LLMs with more human-aligned conceptual representations.</p></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://www.theregister.com/2025/03/29/malware_obscure_languages/">Malware in Lisp? Now you&#x27;re just being cruel</a></div><div class="ArticlePreview_summary__Zyb4E"><p>: Miscreants warming to Delphi, Haskell, and the like to evade detection</p></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://stackbench.ai/">Analyze how well coding agents use your libraries and frameworks</a></div><div class="ArticlePreview_summary__Zyb4E"><p>Test your library&#x27;s agent-friendliness by analyzing how well coding agents use your documentation</p></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://github.com/hasktorch/hasktorch">hasktorch/hasktorch</a></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://www.theverge.com/24167865/google-zero-search-crash-housefresh-ai-overviews-traffic-data-audience">Google Zero is here — now what?</a></div><div class="ArticlePreview_summary__Zyb4E"><p>Search is a foundational platform the modern web was built on. But all platforms come and go — so what’s next?</p></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://dl.acm.org/doi/10.1007/11561347_18">Multi-stage programming with functors and monads | Proceedings of the 4th international conference on Generative Programming and Component Engineering</a></div><div class="ArticlePreview_summary__Zyb4E"><p>With Gaussian Elimination as a representative family of numerical and symbolic algorithms, we use multi-stage programming, monads and Ocaml&#x27;s advanced module system to demonstrate the complete elimination of the abstraction overhead while avoiding any inspection of the generated code. We parameterize our Gaussian Elimination code to a great extent (over domain, matrix representations, determinant tracking, pivoting policies, result types, etc) at no run-time cost. Because the resulting code is generated just right and not changed afterwards, we enjoy MetaOCaml&#x27;s guaranty that the generated code is well-typed. We further demonstrate that various abstraction parameters (aspects) can be made orthogonal and compositional, even in the presence of name-generation for temporaries and other bindings and “interleaving” of aspects. We also show how to encode some domain-specific knowledge so that “clearly wrong” compositions can be statically rejected by the compiler when processing the generator rather than the generated code.</p></div></div></div></div><div class="page_controls__bJjEu"><a class="page_button__2bNeO" href="/url-notes/all/0">newer</a><a class="page_button__2bNeO" href="/url-notes/all/2">older</a></div></div><!--$--><!--/$--><script src="/url-notes/_next/static/chunks/webpack-54d9d4b2aa649176.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n5:I[9665,[],\"OutletBoundary\"]\n7:I[4911,[],\"AsyncMetadataOutlet\"]\n9:I[9665,[],\"ViewportBoundary\"]\nb:I[9665,[],\"MetadataBoundary\"]\nc:\"$Sreact.suspense\"\ne:I[8393,[],\"\"]\n:HL[\"/url-notes/_next/static/css/f03c873af434c7c6.css\",\"style\"]\n:HL[\"/url-notes/_next/static/css/0e5ea1ea0183b412.css\",\"style\"]\n:HL[\"/url-notes/_next/static/css/7190d9c623ab1fe0.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"UE-zlTBY9TySNjoJB9Enp\",\"p\":\"/url-notes\",\"c\":[\"\",\"all\",\"1\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"all\",{\"children\":[[\"pageIndex\",\"1\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/url-notes/_next/static/css/f03c873af434c7c6.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"all\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"pageIndex\",\"1\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/url-notes/_next/static/css/0e5ea1ea0183b412.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/url-notes/_next/static/css/7190d9c623ab1fe0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$L5\",null,{\"children\":[\"$L6\",[\"$\",\"$L7\",null,{\"promise\":\"$@8\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$L9\",null,{\"children\":\"$La\"}],null],[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$c\",null,{\"fallback\":null,\"children\":\"$Ld\"}]}]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$e\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n6:null\n"])</script><script>self.__next_f.push([1,"f:I[6874,[\"874\",\"static/chunks/874-437a265a67d6cfee.js\",\"216\",\"static/chunks/app/all/%5BpageIndex%5D/page-680db69597409d20.js\"],\"\"]\n1d:I[8175,[],\"IconMark\"]\n10:T67a,"])</script><script>self.__next_f.push([1,"Training large language models (LLMs) on source code significantly enhances their general-purpose reasoning abilities, but the mechanisms underlying this generalisation are poorly understood. In this paper, we propose Programming by Backprop (PBB) as a potential driver of this effect - teaching a model to evaluate a program for inputs by training on its source code alone, without ever seeing I/O examples. To explore this idea, we finetune LLMs on two sets of programs representing simple maths problems and algorithms: one with source code and I/O examples (w/ IO), the other with source code only (w/o IO). We find evidence that LLMs have some ability to evaluate w/o IO programs for inputs in a range of experimental settings, and make several observations. Firstly, PBB works significantly better when programs are provided as code rather than semantically equivalent language descriptions. Secondly, LLMs can produce outputs for w/o IO programs directly, by implicitly evaluating the program within the forward pass, and more reliably when stepping through the program in-context via chain-of-thought. We further show that PBB leads to more robust evaluation of programs across inputs than training on I/O pairs drawn from a distribution that mirrors naturally occurring data. Our findings suggest a mechanism for enhanced reasoning through code training: it allows LLMs to internalise reusable algorithmic abstractions. Significant scope remains for future work to enable LLMs to more effectively learn from symbolic procedures, and progress in this direction opens other avenues like model alignment by training on formal constitutional principles."])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"page_Page__nS49m\",\"children\":[[\"$\",\"div\",null,{\"className\":\"Header_Header__VDN4T\",\"children\":[[\"$\",\"div\",null,{\"className\":\"Header_item__PWJos\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"/\",\"children\":\"url-notes\"}]}],[[[\"$\",\"div\",\"separator-0\",{\"className\":\"Header_separator__zF22U\",\"children\":\"|\"}],[\"$\",\"div\",\"item-0\",{\"className\":\"Header_item__PWJos\",\"children\":[\"$\",\"$Lf\",\"0\",{\"href\":\"/all/0\",\"children\":\"all\"}]}]],[[\"$\",\"div\",\"separator-1\",{\"className\":\"Header_separator__zF22U\",\"children\":\"|\"}],[\"$\",\"div\",\"item-1\",{\"className\":\"Header_item__PWJos\",\"children\":[\"$\",\"span\",\"1\",{\"children\":[\"page \",2,\" of \",16]}]}]]]]}],[\"$\",\"div\",null,{\"className\":\"page_content___i7Ut\",\"children\":[\"$\",\"div\",null,{\"className\":\"page_previews__BuBMS\",\"children\":[[\"$\",\"div\",\"0\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"https://arxiv.org/pdf/2506.18777\",\"target\":\"_blank\",\"children\":\"Programming by Backprop: LLMs Acquire Reusable Algorithmic Abstractions During Code Training\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$Lf\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Artificial%20Intelligence\",\"children\":\"Artificial Intelligence\"}],[\"$\",\"$Lf\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Computation%20and%20Language\",\"children\":\"Computation and Language\"}],[\"$\",\"$Lf\",\"2\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Machine%20Learning\",\"children\":\"Machine Learning\"}]]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"$10\"}]]}]]}],[\"$\",\"div\",\"1\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"https://arxiv.org/pdf/2506.17871\",\"target\":\"_blank\",\"children\":\"How Alignment Shrinks the Generative Horizon\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$Lf\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/\",\"children\":\"\"}],[\"$\",\"$Lf\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Computation%20and%20Language\",\"children\":\"Computation and Language\"}],\"$L11\",\"$L12\"]}],\"$L13\"]}],\"$L14\",\"$L15\",\"$L16\",\"$L17\",\"$L18\",\"$L19\",\"$L1a\",\"$L1b\"]}]}],\"$L1c\"]}]\n"])</script><script>self.__next_f.push([1,"8:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"url-notes | all | page 2 of 16\"}],[\"$\",\"link\",\"1\",{\"rel\":\"icon\",\"href\":\"/url-notes/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"256x256\"}],[\"$\",\"$L1d\",\"2\",{}]],\"error\":null,\"digest\":\"$undefined\"}\nd:\"$8:metadata\"\n"])</script><script>self.__next_f.push([1,"11:[\"$\",\"$Lf\",\"2\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Artificial%20Intelligence\",\"children\":\"Artificial Intelligence\"}]\n12:[\"$\",\"$Lf\",\"3\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Machine%20Learning\",\"children\":\"Machine Learning\"}]\n1e:T735,"])</script><script>self.__next_f.push([1,"Despite their impressive capabilities, aligned large language models (LLMs) often generate outputs that lack diversity. What drives this stability in the generation? We investigate this phenomenon through the lens of probability concentration in the model's output distribution. To quantify this concentration, we introduce the Branching Factor (BF) -- a token-invariant measure of the effective number of plausible next steps during generation. Our empirical analysis reveals two key findings: (1) BF often decreases as generation progresses, suggesting that LLMs become more predictable as they generate. (2) alignment tuning substantially sharpens the model's output distribution from the outset, reducing BF by nearly an order of magnitude (e.g., from 12 to 1.2) relative to base models. This stark reduction helps explain why aligned models often appear less sensitive to decoding strategies. Building on this insight, we find this stability has surprising implications for complex reasoning. Aligned Chain-of-Thought (CoT) models (e.g., DeepSeek-distilled models), for instance, leverage this effect; by generating longer reasoning chains, they push generation into later, more deterministic (lower BF) stages, resulting in more stable outputs. We hypothesize that alignment tuning does not fundamentally change a model's behavior, but instead steers it toward stylistic tokens (e.g., \"Sure\") that unlock low-entropy trajectories already present in the base model. This view is supported by nudging experiments, which show that prompting base models with such tokens can similarly reduce BF. Together, our findings establish BF as a powerful diagnostic for understanding and controlling LLM outputs - clarifying how alignment reduces variability, how CoT promotes stable generations, and how base models can be steered away from diversity."])</script><script>self.__next_f.push([1,"13:[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"$1e\"}]]}]\n1f:T475,"])</script><script>self.__next_f.push([1,"Large language models (LLMs) are regularly evaluated using benchmark datasets. But what justifies making inferences about an LLM's capabilities based on its answers to a curated set of questions? This paper first introduces a formal framework to address this question. The key is to note that the benchmarks used to test LLMs -- such as AP exams -- are also those used to test people. However, this raises an implication: these benchmarks are only valid tests if LLMs misunderstand concepts in ways that mirror human misunderstandings. Otherwise, success on benchmarks only demonstrates potemkin understanding: the illusion of understanding driven by answers irreconcilable with how any human would interpret a concept. We present two procedures for quantifying the existence of potemkins: one using a specially designed benchmark in three domains, the other using a general procedure that provides a lower-bound on their prevalence. We find that potemkins are ubiquitous across models, tasks, and domains. We also find that these failures reflect not just incorrect understanding, but deeper internal incoherence in concept representations."])</script><script>self.__next_f.push([1,"14:[\"$\",\"div\",\"2\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"https://arxiv.org/pdf/2506.21521\",\"target\":\"_blank\",\"children\":\"Potemkin Understanding in Large Language Models\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$Lf\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Computation%20and%20Language\",\"children\":\"Computation and Language\"}],[\"$\",\"$Lf\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Artificial%20Intelligence\",\"children\":\"Artificial Intelligence\"}]]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"$1f\"}]]}]]}]\n"])</script><script>self.__next_f.push([1,"20:T75d,"])</script><script>self.__next_f.push([1,"https://download.ssrn.com/2025/6/30/4440242.pdf?response-content-disposition=attachment%3B%20filename%3Dssrn-4440242.pdf\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjENb%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJHMEUCIQDmvD0kwhxUvwfI51pkPe7LHJvlbunkSaSJ%2F%2FWUHoHLxwIgKvlIsW8iuAAP7s8oth%2F9YaKIKpRZ81hCBzCyI8YDF5oqxQUIz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAEGgwzMDg0NzUzMDEyNTciDPFDIhL%2BP88i2OXZ6SqZBefQZOwOYYLdg%2BqExabceAZ%2BrERHWnxBuYo%2BE3mBpdQ5F230f6aZ0YPQPQLAlDLggStpWurCRPjzdUpiah95RWY5%2Fho%2B%2BIJMQt%2BXlP2zJ0tH%2Bjc8L44sVb5xro0WdeoEbn9kv1HEEgPlyJYK9VnuSWakRRvq2rYBQF9GGYtOSNRKqubOHX3sn0Otqt0i4xN5FuayIg0CPeZtJ2ZgN%2FEH%2FDw6oir%2BvSvn%2FtOXrpYNe74yps2euHd9iiv21zZRIGlGwmKnrd%2F5lsjBUoLnOSd9VAa%2BqKrYp9ivQfcCB7Oqe9Rj4iLjh8TeVCyRqkXwBxbOOhxW8gomEJOcjOJpiTOeNooyzLgR7FZqo2h8ia6aVyhHQPTDvCQgtLLc%2FYQnd%2FQ9qZWwx2%2FbXqeXsNI5Or2qcgPy8Ul4%2F%2FeuLHbFsLA6FnY%2Fz5HbC%2BNoQP3SV3od4tYKPESNObQOMKixm7iq5TIdK1OzaeQhlSpGdFs7GWwiAWqXNDHVVFbdXLDczvSPpEaubfmUUhLiZaZA05HLMpMBrsDXgPfjVxwikIyC20x1NfE2G6diCN5zCaqR5l5Jh4lzKXTOKDZcs8iJs3I4mjCKmRn3BqSuWlaSI4K049EVQvifWBF8Oz42Yub0UXIbns659tipXWgnpe2t9dkVKEzRt4ENmyOi%2FaUHPxeQkigTmXHR0Cmb%2FYagZpfp5knBLBXlCjZxy3OlLDs8qZmvXreW4cBEts7UNy8IQLeuoxBYkr4nbNreSYRpTjw4tcG9zPmUUzuRVSt6VF07W5KJ1jQqTI4aJ4wtmWSgMFopPVGiyduaToM7%2FBxMY5gpV2ZsByt%2BJCObeZrUyRfq2HwHoWC5wGMiOjtsYe%2Bmetmp890mAOxL6VJowA%2Bl9Kh%2FMOnqjcMGOrEB18AnWgBDmlKkSscFIxJOL33ixrSai7YAjhHXpoVSUh3B0Z%2BMO2iO4XxEAzuzYhL9J%2BovhoVJ9GaFJdmMOqrxN1CRHitVibPr0mE0wZyNGqpu%2FjWOg6wvjLuET7Wxt7jxHMzmdpPEO26pBemUMHTSjbGtrC7Asc7wbAusIZ%2Fcuqy8B6MgLkiLi1QOIjBHzY7Vs6p2nu5u%2BjF4%2Fld1vyCVhsoH6J5EoMRRyixpRF4qv3T0\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Date=20250701T054517Z\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Expires=300\u0026X-Amz-Credential=ASIAUPUUPRWE7AM5UVQA%2F20250701%2Fus-east-1%2Fs3%2Faws4_request\u0026X-Amz-Signature=50a47418d1bede25e5f619afb7a74d57c0d0600407a48e401744a96f24f59ed8\u0026abstractId=4440242"])</script><script>self.__next_f.push([1,"15:[\"$\",\"div\",\"3\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"$20\",\"target\":\"_blank\",\"children\":\"Cancel Culture\"}]}],\"$undefined\",[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":\"\u003cdiv\u003e\\n \u003cdiv\u003e\\n  Public controversies over employee speech where individuals face backlash for expressing views deemed controversial, \u003cspan\u003eunpopular, or mis\"}]]}]\n21:T5a6,"])</script><script>self.__next_f.push([1,"Humans organize knowledge into compact categories through semantic compression by mapping diverse instances to abstract representations while preserving meaning (e.g., robin and blue jay are both birds; most birds can fly). These concepts reflect a trade-off between expressive fidelity and representational simplicity. Large Language Models (LLMs) demonstrate remarkable linguistic abilities, yet whether their internal representations strike a human-like trade-off between compression and semantic fidelity is unclear. We introduce a novel information-theoretic framework, drawing from Rate-Distortion Theory and the Information Bottleneck principle, to quantitatively compare these strategies. Analyzing token embeddings from a diverse suite of LLMs against seminal human categorization benchmarks, we uncover key divergences. While LLMs form broad conceptual categories that align with human judgment, they struggle to capture the fine-grained semantic distinctions crucial for human understanding. More fundamentally, LLMs demonstrate a strong bias towards aggressive statistical compression, whereas human conceptual systems appear to prioritize adaptive nuance and contextual richness, even if this results in lower compressional efficiency by our measures. These findings illuminate critical differences between current AI and human cognitive architectures, guiding pathways toward LLMs with more human-aligned conceptual representations."])</script><script>self.__next_f.push([1,"16:[\"$\",\"div\",\"4\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"https://yosefk.com/blog/llms-arent-world-models.htmlhttps://arxiv.org/pdf/2505.17117\",\"target\":\"_blank\",\"children\":\"From Tokens to Thoughts: How LLMs and Humans Trade Compression for Meaning\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$Lf\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Computation%20and%20Language\",\"children\":\"Computation and Language\"}],[\"$\",\"$Lf\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Artificial%20Intelligence\",\"children\":\"Artificial Intelligence\"}],[\"$\",\"$Lf\",\"2\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Information%20Theory\",\"children\":\"Information Theory\"}],[\"$\",\"$Lf\",\"3\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/Information%20Theory\",\"children\":\"Information Theory\"}]]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"$21\"}]]}]]}]\n"])</script><script>self.__next_f.push([1,"17:[\"$\",\"div\",\"5\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"https://www.theregister.com/2025/03/29/malware_obscure_languages/\",\"target\":\"_blank\",\"children\":\"Malware in Lisp? Now you're just being cruel\"}]}],\"$undefined\",[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\": Miscreants warming to Delphi, Haskell, and the like to evade detection\"}]]}]]}]\n18:[\"$\",\"div\",\"6\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"https://stackbench.ai/\",\"target\":\"_blank\",\"children\":\"Analyze how well coding agents use your libraries and frameworks\"}]}],\"$undefined\",[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"Test your library's agent-friendliness by analyzing how well coding agents use your documentation\"}]]}]]}]\n19:[\"$\",\"div\",\"7\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"https://github.com/hasktorch/hasktorch\",\"target\":\"_blank\",\"children\":\"hasktorch/hasktorch\"}]}],\"$undefined\",\"$undefined\"]}]\n1a:[\"$\",\"div\",\"8\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"https://www.theverge.com/24167865/google-zero-search-crash-housefresh-ai-overviews-traffic-data-audience\",\"target\":\"_blank\",\"children\":\"Google Zero is here — now what?\"}]}],\"$undefined\",[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"Search is a foundational platform the modern web was built on. But all platforms come and go — so what’s next?\"}]]}]]}]\n22:T411,"])</script><script>self.__next_f.push([1,"With Gaussian Elimination as a representative family of numerical and symbolic algorithms, we use multi-stage programming, monads and Ocaml's advanced module system to demonstrate the complete elimination of the abstraction overhead while avoiding any inspection of the generated code. We parameterize our Gaussian Elimination code to a great extent (over domain, matrix representations, determinant tracking, pivoting policies, result types, etc) at no run-time cost. Because the resulting code is generated just right and not changed afterwards, we enjoy MetaOCaml's guaranty that the generated code is well-typed. We further demonstrate that various abstraction parameters (aspects) can be made orthogonal and compositional, even in the presence of name-generation for temporaries and other bindings and “interleaving” of aspects. We also show how to encode some domain-specific knowledge so that “clearly wrong” compositions can be statically rejected by the compiler when processing the generator rather than the generated code."])</script><script>self.__next_f.push([1,"1b:[\"$\",\"div\",\"9\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$Lf\",null,{\"href\":\"https://dl.acm.org/doi/10.1007/11561347_18\",\"target\":\"_blank\",\"children\":\"Multi-stage programming with functors and monads | Proceedings of the 4th international conference on Generative Programming and Component Engineering\"}]}],\"$undefined\",[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"$22\"}]]}]]}]\n1c:[\"$\",\"div\",null,{\"className\":\"page_controls__bJjEu\",\"children\":[[\"$\",\"$Lf\",null,{\"className\":\"page_button__2bNeO\",\"href\":\"/all/0\",\"children\":\"newer\"}],[\"$\",\"$Lf\",null,{\"className\":\"page_button__2bNeO\",\"href\":\"/all/2\",\"children\":\"older\"}]]}]\n"])</script></body></html>