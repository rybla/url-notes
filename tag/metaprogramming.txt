1:"$Sreact.fragment"
2:I[7555,[],""]
3:I[1295,[],""]
5:I[9665,[],"OutletBoundary"]
7:I[4911,[],"AsyncMetadataOutlet"]
9:I[9665,[],"ViewportBoundary"]
b:I[9665,[],"MetadataBoundary"]
c:"$Sreact.suspense"
e:I[8393,[],""]
:HL["/url-notes/_next/static/css/f03c873af434c7c6.css","style"]
:HL["/url-notes/_next/static/css/0e5ea1ea0183b412.css","style"]
:HL["/url-notes/_next/static/css/a9d1307f18e49070.css","style"]
0:{"P":null,"b":"HHf8jOZ8wqjLnhweFigGn","p":"/url-notes","c":["","tag","metaprogramming"],"i":false,"f":[[["",{"children":["tag",{"children":[["tag","metaprogramming","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/url-notes/_next/static/css/f03c873af434c7c6.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["tag",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["tag","metaprogramming","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",[["$","link","0",{"rel":"stylesheet","href":"/url-notes/_next/static/css/0e5ea1ea0183b412.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/url-notes/_next/static/css/a9d1307f18e49070.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$L5",null,{"children":["$L6",["$","$L7",null,{"promise":"$@8"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,[["$","$L9",null,{"children":"$La"}],null],["$","$Lb",null,{"children":["$","div",null,{"hidden":true,"children":["$","$c",null,{"fallback":null,"children":"$Ld"}]}]}]]}],false]],"m":"$undefined","G":["$e",[]],"s":false,"S":true}
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
6:null
f:I[8175,[],"IconMark"]
8:{"metadata":[["$","title","0",{"children":"url-notes | tag | metaprogramming"}],["$","link","1",{"rel":"icon","href":"/url-notes/favicon.ico","type":"image/x-icon","sizes":"256x256"}],["$","$Lf","2",{}]],"error":null,"digest":"$undefined"}
d:"$8:metadata"
10:I[6874,["874","static/chunks/874-437a265a67d6cfee.js","296","static/chunks/app/tag/%5Btag%5D/page-42d05b4590119831.js"],""]
4:["$","div",null,{"className":"$undefined","children":[["$","div",null,{"className":"Header_Header__VDN4T","children":[["$","div",null,{"className":"Header_item__PWJos","children":["$","$L10",null,{"href":"/","children":"url-notes"}]}],[[["$","div","separator-0",{"className":"Header_separator__zF22U","children":"|"}],["$","div","item-0",{"className":"Header_item__PWJos","children":["$","$L10","0",{"href":"/tags","children":"tag"}]}]],[["$","div","separator-1",{"className":"Header_separator__zF22U","children":"|"}],["$","div","item-1",{"className":"Header_item__PWJos","children":["$","$L10","1",{"href":"/tags","children":"tag"}]}]],[["$","div","separator-2",{"className":"Header_separator__zF22U","children":"|"}],["$","div","item-2",{"className":"Header_item__PWJos","children":["$","span","2",{"children":"metaprogramming"}]}]]]]}],["$","div",null,{"className":"page_content__fAQW6","children":["$","div",null,{"className":"page_previews__SpAnf","children":[["$","div","0",{"className":"ArticlePreview_ArticlePreview__59E_4","children":[["$","div",null,{"className":"ArticlePreview_title__Snpua","children":["$","$L10",null,{"href":"https://mpickering.github.io/papers/multi-stage-programs-in-context.pdf","target":"_blank","children":"Multi-stage Programs in Context"}]}],["$","div",null,{"className":"ArticlePreview_tags__y8wnE","children":[["$","$L10","0",{"className":"ArticlePreview_tag___oIyn","href":"/tag/multi-stage%20programming","children":"multi-stage programming"}],["$","$L10","1",{"className":"ArticlePreview_tag___oIyn","href":"/tag/metaprogramming","children":"metaprogramming"}],["$","$L10","2",{"className":"ArticlePreview_tag___oIyn","href":"/tag/haskell","children":"haskell"}],["$","$L10","3",{"className":"ArticlePreview_tag___oIyn","href":"/tag/typed%20template%20haskell","children":"typed template haskell"}],["$","$L10","4",{"className":"ArticlePreview_tag___oIyn","href":"/tag/compilers","children":"compilers"}],["$","$L10","5",{"className":"ArticlePreview_tag___oIyn","href":"/tag/ghc","children":"ghc"}],["$","$L10","6",{"className":"ArticlePreview_tag___oIyn","href":"/tag/type%20theory","children":"type theory"}],["$","$L10","7",{"className":"ArticlePreview_tag___oIyn","href":"/tag/functional%20programming","children":"functional programming"}],["$","$L10","8",{"className":"ArticlePreview_tag___oIyn","href":"/tag/code%20generation","children":"code generation"}],["$","$L10","9",{"className":"ArticlePreview_tag___oIyn","href":"/tag/type%20inference","children":"type inference"}],["$","$L10","10",{"className":"ArticlePreview_tag___oIyn","href":"/tag/type%20classes","children":"type classes"}],["$","$L10","11",{"className":"ArticlePreview_tag___oIyn","href":"/tag/context%20preservation","children":"context preservation"}],["$","$L10","12",{"className":"ArticlePreview_tag___oIyn","href":"/tag/metaprogramming","children":"metaprogramming"}],["$","$L10","13",{"className":"ArticlePreview_tag___oIyn","href":"/tag/staging","children":"staging"}],["$","$L10","14",{"className":"ArticlePreview_tag___oIyn","href":"/tag/implicits","children":"implicits"}]]}],["$","div",null,{"className":"ArticlePreview_summary__Zyb4E","children":[["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong","strong-0",{"children":"Core Problem"}],": In multi-stage programming (like Typed Template Haskell), quoting code (",["$","code","code-0",{"children":"JeK"}],") discards implicit, context-derived information such as inferred types, type class instances, and implicit parameters. When the code is later spliced (",["$","code","code-1",{"children":"$$(e)"}],"), this missing information can lead to ambiguity errors or the selection of incorrect type class instances, especially with overlapping instances."]}],"\n",["$","li","li-1",{"children":[["$","strong","strong-0",{"children":"Proposed Solution"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":["Represent quoted terms using a type-preserving format (GHC's ",["$","code","code-0",{"children":"CoreExpr"}],") instead of a purely syntactic AST. This captures the results of type inference and elaboration (e.g., which type class dictionary to use) at the quotation site."]}],"\n",["$","li","li-1",{"children":"Extend the principles of cross-stage persistence to cover implicit information."}],"\n","$L11","\n","$L12","\n"]}],"\n"]}],"\n","$L13","\n","$L14","\n"]}]]}]]}],"$L15","$L16","$L17"]}]}]]}]
11:["$","li","li-2",{"children":["Introduce a ",["$","code","code-0",{"children":"LiftT"}]," type class to persist types across stages, analogous to the ",["$","code","code-1",{"children":"Lift"}]," class for values. This solves ambiguity by ensuring type variables bound in an outer stage are correctly instantiated in an inner stage."]}]
12:["$","li","li-3",{"children":["Formalize the system with a calculus, ",["$","code","code-0",{"children":"λ⇑"}],", that explicitly models staging levels and the elaboration of implicit information."]}]
13:["$","li","li-2",{"children":[["$","strong","strong-0",{"children":"Implementation"}],": The paper details an implementation in GHC where typed quotations are serialized as ",["$","code","code-0",{"children":"CoreExpr"}],". This avoids re-typechecking at the splice site, prevents scope extrusion errors, and allows GHC's optimizer to work on the generated code."]}]
14:["$","li","li-3",{"children":[["$","strong","strong-0",{"children":"Key Insight"}],": The meaning of a quoted program fragment is not just its syntax but also the implicit context in which it was created. This context must be preserved in the representation to ensure correctness."]}]
18:T411,With Gaussian Elimination as a representative family of numerical and symbolic algorithms, we use multi-stage programming, monads and Ocaml's advanced module system to demonstrate the complete elimination of the abstraction overhead while avoiding any inspection of the generated code. We parameterize our Gaussian Elimination code to a great extent (over domain, matrix representations, determinant tracking, pivoting policies, result types, etc) at no run-time cost. Because the resulting code is generated just right and not changed afterwards, we enjoy MetaOCaml's guaranty that the generated code is well-typed. We further demonstrate that various abstraction parameters (aspects) can be made orthogonal and compositional, even in the presence of name-generation for temporaries and other bindings and “interleaving” of aspects. We also show how to encode some domain-specific knowledge so that “clearly wrong” compositions can be statically rejected by the compiler when processing the generator rather than the generated code.15:["$","div","1",{"className":"ArticlePreview_ArticlePreview__59E_4","children":[["$","div",null,{"className":"ArticlePreview_title__Snpua","children":["$","$L10",null,{"href":"https://dl.acm.org/doi/10.1007/11561347_18","target":"_blank","children":"Multi-stage programming with functors and monads | Proceedings of the 4th international conference on Generative Programming and Component Engineering"}]}],["$","div",null,{"className":"ArticlePreview_tags__y8wnE","children":[["$","$L10","0",{"className":"ArticlePreview_tag___oIyn","href":"/tag/multi-stage%20programming","children":"multi-stage programming"}],["$","$L10","1",{"className":"ArticlePreview_tag___oIyn","href":"/tag/functional%20programming","children":"functional programming"}],["$","$L10","2",{"className":"ArticlePreview_tag___oIyn","href":"/tag/ocaml","children":"ocaml"}],["$","$L10","3",{"className":"ArticlePreview_tag___oIyn","href":"/tag/metaocaml","children":"metaocaml"}],["$","$L10","4",{"className":"ArticlePreview_tag___oIyn","href":"/tag/monads","children":"monads"}],["$","$L10","5",{"className":"ArticlePreview_tag___oIyn","href":"/tag/functors","children":"functors"}],["$","$L10","6",{"className":"ArticlePreview_tag___oIyn","href":"/tag/generative%20programming","children":"generative programming"}],["$","$L10","7",{"className":"ArticlePreview_tag___oIyn","href":"/tag/metaprogramming","children":"metaprogramming"}],["$","$L10","8",{"className":"ArticlePreview_tag___oIyn","href":"/tag/compilers","children":"compilers"}],["$","$L10","9",{"className":"ArticlePreview_tag___oIyn","href":"/tag/type%20systems","children":"type systems"}],["$","$L10","10",{"className":"ArticlePreview_tag___oIyn","href":"/tag/gaussian%20elimination","children":"gaussian elimination"}],["$","$L10","11",{"className":"ArticlePreview_tag___oIyn","href":"/tag/numerical%20algorithms","children":"numerical algorithms"}],["$","$L10","12",{"className":"ArticlePreview_tag___oIyn","href":"/tag/symbolic%20algorithms","children":"symbolic algorithms"}],["$","$L10","13",{"className":"ArticlePreview_tag___oIyn","href":"/tag/performance%20optimization","children":"performance optimization"}],["$","$L10","14",{"className":"ArticlePreview_tag___oIyn","href":"/tag/abstraction%20overhead","children":"abstraction overhead"}],["$","$L10","15",{"className":"ArticlePreview_tag___oIyn","href":"/tag/code%20generation","children":"code generation"}],["$","$L10","16",{"className":"ArticlePreview_tag___oIyn","href":"/tag/aspect-oriented%20programming","children":"aspect-oriented programming"}]]}],["$","div",null,{"className":"ArticlePreview_summary__Zyb4E","children":[["$","p","p-0",{"children":"$18"}]]}]]}]
16:["$","div","2",{"className":"ArticlePreview_ArticlePreview__59E_4","children":[["$","div",null,{"className":"ArticlePreview_title__Snpua","children":["$","$L10",null,{"href":"https://okmij.org/ftp/ML/MetaOCaml.html","target":"_blank","children":"MetaOCaml -- an OCaml dialect for multi-stage programming"}]}],["$","div",null,{"className":"ArticlePreview_tags__y8wnE","children":[["$","$L10","0",{"className":"ArticlePreview_tag___oIyn","href":"/tag/programming%20languages","children":"programming languages"}],["$","$L10","1",{"className":"ArticlePreview_tag___oIyn","href":"/tag/ocaml","children":"ocaml"}],["$","$L10","2",{"className":"ArticlePreview_tag___oIyn","href":"/tag/metaocaml","children":"metaocaml"}],["$","$L10","3",{"className":"ArticlePreview_tag___oIyn","href":"/tag/multi-stage%20programming","children":"multi-stage programming"}],["$","$L10","4",{"className":"ArticlePreview_tag___oIyn","href":"/tag/metaprogramming","children":"metaprogramming"}],["$","$L10","5",{"className":"ArticlePreview_tag___oIyn","href":"/tag/generative%20programming","children":"generative programming"}],["$","$L10","6",{"className":"ArticlePreview_tag___oIyn","href":"/tag/code%20generation","children":"code generation"}],["$","$L10","7",{"className":"ArticlePreview_tag___oIyn","href":"/tag/compilers","children":"compilers"}],["$","$L10","8",{"className":"ArticlePreview_tag___oIyn","href":"/tag/static%20typing","children":"static typing"}],["$","$L10","9",{"className":"ArticlePreview_tag___oIyn","href":"/tag/type%20safety","children":"type safety"}],["$","$L10","10",{"className":"ArticlePreview_tag___oIyn","href":"/tag/scope%20safety","children":"scope safety"}],["$","$L10","11",{"className":"ArticlePreview_tag___oIyn","href":"/tag/hygiene","children":"hygiene"}],["$","$L10","12",{"className":"ArticlePreview_tag___oIyn","href":"/tag/functional%20programming","children":"functional programming"}],["$","$L10","13",{"className":"ArticlePreview_tag___oIyn","href":"/tag/run-time%20code%20specialization","children":"run-time code specialization"}],["$","$L10","14",{"className":"ArticlePreview_tag___oIyn","href":"/tag/domain-specific%20languages","children":"domain-specific languages"}]]}],["$","div",null,{"className":"ArticlePreview_summary__Zyb4E","children":[["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":["\n",["$","p","p-0",{"children":[["$","strong","strong-0",{"children":"Core Concept"}],": MetaOCaml is a statically-typed, multi-stage programming language, implemented as a conservative extension of OCaml. It is designed for writing programs that generate specialized and optimized code at runtime."]}],"\n"]}],"\n",["$","li","li-1",{"children":["\n",["$","p","p-0",{"children":[["$","strong","strong-0",{"children":"Key Language Constructs"}],":"]}],"\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong","strong-0",{"children":["Code Type (",["$","code","code-0",{"children":"'a code"}],")"]}],": A type representing a fragment of a future-stage program that will produce a value of type ",["$","code","code-0",{"children":"'a"}],"."]}],"\n",["$","li","li-1",{"children":[["$","strong","strong-0",{"children":["Brackets (",["$","code","code-0",{"children":".<e>."}],")"]}],": \"Quotes\" an expression ",["$","code","code-0",{"children":"e"}],", deferring its computation to a later stage and creating a value of type ",["$","code","code-1",{"children":"code"}],"."]}],"\n",["$","li","li-2",{"children":[["$","strong","strong-0",{"children":["Escape (",["$","code","code-0",{"children":".~e"}],")"]}],": Used within brackets to splice the result of a present-stage computation (which must be of a ",["$","code","code-0",{"children":"code"}]," type) into the generated code."]}],"\n"]}],"\n"]}],"\n",["$","li","li-2",{"children":["\n",["$","p","p-0",{"children":[["$","strong","strong-0",{"children":"Static Guarantees"}],":"]}],"\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong","strong-0",{"children":"Type Safety"}],": A well-typed MetaOCaml program is guaranteed to generate well-typed OCaml code. Type errors are caught in the generator, not the generated code."]}],"\n",["$","li","li-1",{"children":[["$","strong","strong-0",{"children":"Scope Safety (Hygiene)"}],": Lexical scope is preserved. A dynamic \"scope extrusion\" check aborts generation if a variable would escape its binder, providing a strong guarantee of well-scoped code. This replaces the older, less comprehensive static \"environment classifier\" system."]}],"\n"]}],"\n"]}],"\n","$L19","\n","$L1a","\n"]}]]}]]}]
17:["$","div","3",{"className":"ArticlePreview_ArticlePreview__59E_4","children":[["$","div",null,{"className":"ArticlePreview_title__Snpua","children":["$","$L10",null,{"href":"https://haskellweekly.news/issue/485.html","target":"_blank","children":"Issue 485"}]}],["$","div",null,{"className":"ArticlePreview_tags__y8wnE","children":[["$","$L10","0",{"className":"ArticlePreview_tag___oIyn","href":"/tag/haskell","children":"haskell"}],["$","$L10","1",{"className":"ArticlePreview_tag___oIyn","href":"/tag/community","children":"community"}],["$","$L10","2",{"className":"ArticlePreview_tag___oIyn","href":"/tag/education","children":"education"}],["$","$L10","3",{"className":"ArticlePreview_tag___oIyn","href":"/tag/mentorship","children":"mentorship"}],["$","$L10","4",{"className":"ArticlePreview_tag___oIyn","href":"/tag/podcast","children":"podcast"}],["$","$L10","5",{"className":"ArticlePreview_tag___oIyn","href":"/tag/stm","children":"stm"}],["$","$L10","6",{"className":"ArticlePreview_tag___oIyn","href":"/tag/laziness","children":"laziness"}],["$","$L10","7",{"className":"ArticlePreview_tag___oIyn","href":"/tag/type-driven%20development","children":"type-driven development"}],["$","$L10","8",{"className":"ArticlePreview_tag___oIyn","href":"/tag/domain-driven%20design","children":"domain-driven design"}],["$","$L10","9",{"className":"ArticlePreview_tag___oIyn","href":"/tag/performance","children":"performance"}],["$","$L10","10",{"className":"ArticlePreview_tag___oIyn","href":"/tag/caching","children":"caching"}],["$","$L10","11",{"className":"ArticlePreview_tag___oIyn","href":"/tag/memory%20management","children":"memory management"}],["$","$L10","12",{"className":"ArticlePreview_tag___oIyn","href":"/tag/cpu%20performance","children":"cpu performance"}],["$","$L10","13",{"className":"ArticlePreview_tag___oIyn","href":"/tag/type%20inference","children":"type inference"}],["$","$L10","14",{"className":"ArticlePreview_tag___oIyn","href":"/tag/json","children":"json"}],["$","$L10","15",{"className":"ArticlePreview_tag___oIyn","href":"/tag/yaml","children":"yaml"}],["$","$L10","16",{"className":"ArticlePreview_tag___oIyn","href":"/tag/template%20haskell","children":"template haskell"}],["$","$L10","17",{"className":"ArticlePreview_tag___oIyn","href":"/tag/metaprogramming","children":"metaprogramming"}],["$","$L10","18",{"className":"ArticlePreview_tag___oIyn","href":"/tag/structural%20subtyping","children":"structural subtyping"}],["$","$L10","19",{"className":"ArticlePreview_tag___oIyn","href":"/tag/code%20transformation","children":"code transformation"}],["$","$L10","20",{"className":"ArticlePreview_tag___oIyn","href":"/tag/database","children":"database"}],["$","$L10","21",{"className":"ArticlePreview_tag___oIyn","href":"/tag/batching","children":"batching"}],["$","$L10","22",{"className":"ArticlePreview_tag___oIyn","href":"/tag/query%20optimization","children":"query optimization"}],["$","$L10","23",{"className":"ArticlePreview_tag___oIyn","href":"/tag/jobs","children":"jobs"}],["$","$L10","24",{"className":"ArticlePreview_tag___oIyn","href":"/tag/e-commerce","children":"e-commerce"}],["$","$L10","25",{"className":"ArticlePreview_tag___oIyn","href":"/tag/game%20engine","children":"game engine"}],["$","$L10","26",{"className":"ArticlePreview_tag___oIyn","href":"/tag/ecs","children":"ecs"}],["$","$L10","27",{"className":"ArticlePreview_tag___oIyn","href":"/tag/ghc","children":"ghc"}],["$","$L10","28",{"className":"ArticlePreview_tag___oIyn","href":"/tag/static%20binaries","children":"static binaries"}],["$","$L10","29",{"className":"ArticlePreview_tag___oIyn","href":"/tag/docker","children":"docker"}],["$","$L10","30",{"className":"ArticlePreview_tag___oIyn","href":"/tag/tooling","children":"tooling"}],["$","$L10","31",{"className":"ArticlePreview_tag___oIyn","href":"/tag/haddock","children":"haddock"}],["$","$L10","32",{"className":"ArticlePreview_tag___oIyn","href":"/tag/documentation","children":"documentation"}],["$","$L10","33",{"className":"ArticlePreview_tag___oIyn","href":"/tag/3d%20models","children":"3d models"}],["$","$L10","34",{"className":"ArticlePreview_tag___oIyn","href":"/tag/hasktorch","children":"hasktorch"}],["$","$L10","35",{"className":"ArticlePreview_tag___oIyn","href":"/tag/machine%20learning","children":"machine learning"}],["$","$L10","36",{"className":"ArticlePreview_tag___oIyn","href":"/tag/linear%20regression","children":"linear regression"}],"$L1b","$L1c","$L1d","$L1e","$L1f","$L20","$L21"]}],"$L22"]}]
19:["$","li","li-3",{"children":["\n",["$","p","p-0",{"children":[["$","strong","strong-0",{"children":"Code Execution & Offshoring"}],":"]}],"\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":["Generated code can be compiled (to bytecode or native code via ",["$","code","code-0",{"children":"Runcode.run"}],") and dynamically linked back into the running program, enabling run-time code specialization."]}],"\n",["$","li","li-1",{"children":[["$","strong","strong-0",{"children":"Offshoring"}],": A subset of the generated OCaml code can be translated into a simple imperative intermediate language, which can then be transcribed to targets like C, LLVM, or OpenCL."]}],"\n"]}],"\n"]}]
1a:["$","li","li-4",{"children":["\n",["$","p","p-0",{"children":[["$","strong","strong-0",{"children":"Advanced Generative Features"}],":"]}],"\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong","strong-0",{"children":["Let-Insertion (",["$","code","code-0",{"children":"genlet"}],")"]}],": A primitive to control evaluation and code motion by explicitly creating ",["$","code","code-0",{"children":"let"}],"-bindings in the generated code. The insertion point is automatically determined to preserve scoping, but can be manually controlled with ",["$","code","code-1",{"children":"locus"}],"."]}],"\n",["$","li","li-1",{"children":[["$","strong","strong-0",{"children":["Recursive Definition Generation (",["$","code","code-0",{"children":"mkgenlet"}],")"]}],": Generates ",["$","code","code-0",{"children":"let rec"}]," bindings for a statically unknown number of mutually recursive functions, useful for specializing recursive functions or generating state machines."]}],"\n",["$","li","li-2",{"children":[["$","strong","strong-0",{"children":["First-Class Patterns (",["$","code","code-0",{"children":"make_match"}],")"]}],": Dynamically constructs ",["$","code","code-0",{"children":"match"}]," expressions from a list of ",["$","code","code-1",{"children":"pat_code"}]," values (function literals), enabling the generation of pattern matches with a variable number of clauses."]}],"\n",["$","li","li-3",{"children":[["$","strong","strong-0",{"children":"Cross-Stage Persistence (CSP)"}],": Allows values from the generator stage to be used in the generated code. Global identifiers are treated as library references. Local identifiers of known serializable types are copied by value; others are handled by reference via closures."]}],"\n"]}],"\n"]}]
1b:["$","$L10","37",{"className":"ArticlePreview_tag___oIyn","href":"/tag/rust","children":"rust"}]
1c:["$","$L10","38",{"className":"ArticlePreview_tag___oIyn","href":"/tag/binary%20tree","children":"binary tree"}]
1d:["$","$L10","39",{"className":"ArticlePreview_tag___oIyn","href":"/tag/data%20structures","children":"data structures"}]
1e:["$","$L10","40",{"className":"ArticlePreview_tag___oIyn","href":"/tag/algorithms","children":"algorithms"}]
1f:["$","$L10","41",{"className":"ArticlePreview_tag___oIyn","href":"/tag/rfc","children":"rfc"}]
20:["$","$L10","42",{"className":"ArticlePreview_tag___oIyn","href":"/tag/bytecode","children":"bytecode"}]
21:["$","$L10","43",{"className":"ArticlePreview_tag___oIyn","href":"/tag/automatic%20differentiation","children":"automatic differentiation"}]
22:["$","div",null,{"className":"ArticlePreview_summary__Zyb4E","children":[["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong","strong-0",{"children":"Featured Articles"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong","strong-0",{"children":"Community & Education"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":"A project update on growing the Haskell userbase through mentorship."}],"\n",["$","li","li-1",{"children":"A podcast with Michael Snoyman discusses newcomer friendliness, STM, and laziness."}],"\n",["$","li","li-2",{"children":"Well-Typed talk recordings from ZuriHac 2025 are now available."}],"\n"]}],"\n"]}],"\n",["$","li","li-1",{"children":[["$","strong","strong-0",{"children":"Development Techniques"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":"Applying Type-Driven Development principles to Domain-Driven Design."}],"\n",["$","li","li-1",{"children":"Using an interning cache to reduce memory residency and improve CPU performance."}],"\n",["$","li","li-2",{"children":"A technique for type inference for plain data structures like JSON/YAML."}],"\n",["$","li","li-3",{"children":"Using Template Haskell to simulate structural subtyping."}],"\n",["$","li","li-4",{"children":"A code-transformation technique using traversals to batch database queries, yielding 100x-300x performance improvements."}],"\n"]}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","li","li-1",{"children":[["$","strong","strong-0",{"children":"Jobs"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":"Bellroy is hiring a Haskell Developer for their e-commerce platform."}],"\n"]}],"\n"]}],"\n",["$","li","li-2",{"children":[["$","strong","strong-0",{"children":"In Brief"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong","strong-0",{"children":"Releases"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":[["$","code","code-0",{"children":"Aztecs"}]," v0.14.0: A modular game engine and Entity Component System (ECS)."]}],"\n",["$","li","li-1",{"children":"GHC 9.10.3-rc3 is now available for testing."}],"\n"]}],"\n"]}],"\n",["$","li","li-1",{"children":[["$","strong","strong-0",{"children":"Tooling"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":[["$","code","code-0",{"children":"hs-static-bin"}],": A new tool to build Haskell static binaries using ad-hoc Docker containers."]}],"\n"]}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","li","li-3",{"children":[["$","strong","strong-0",{"children":"Show & Tell"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":"A method for embedding interactive 3D models into Haddock documentation on Hackage."}],"\n",["$","li","li-1",{"children":["A ",["$","code","code-0",{"children":"hasktorch"}]," example demonstrating linear regression."]}],"\n",["$","li","li-2",{"children":"A comparison of implementing in-order binary tree traversal in Haskell and Rust."}],"\n"]}],"\n"]}],"\n",["$","li","li-4",{"children":[["$","strong","strong-0",{"children":"Call for Participation"}],":","\n",["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":"An RFC proposes introducing a serialisable bytecode format to GHC."}],"\n",["$","li","li-1",{"children":["A feature request for the ",["$","code","code-0",{"children":"horde-ad"}]," library to allow user-provided handwritten derivatives."]}],"\n"]}],"\n"]}],"\n"]}]]}]
