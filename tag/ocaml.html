<!DOCTYPE html><!--HHf8jOZ8wqjLnhweFigGn--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/url-notes/_next/static/css/f03c873af434c7c6.css" data-precedence="next"/><link rel="stylesheet" href="/url-notes/_next/static/css/0e5ea1ea0183b412.css" data-precedence="next"/><link rel="stylesheet" href="/url-notes/_next/static/css/a9d1307f18e49070.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/url-notes/_next/static/chunks/webpack-b3777c3e67e20b2e.js"/><script src="/url-notes/_next/static/chunks/4bd1b696-cf72ae8a39fa05aa.js" async=""></script><script src="/url-notes/_next/static/chunks/964-a29425d4972030f1.js" async=""></script><script src="/url-notes/_next/static/chunks/main-app-e4d4697bcd6cfe75.js" async=""></script><script src="/url-notes/_next/static/chunks/874-437a265a67d6cfee.js" async=""></script><script src="/url-notes/_next/static/chunks/app/tag/%5Btag%5D/page-42d05b4590119831.js" async=""></script><title>url-notes | tag | ocaml</title><link rel="icon" href="/url-notes/favicon.ico" type="image/x-icon" sizes="256x256"/><script src="/url-notes/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><div><div class="Header_Header__VDN4T"><div class="Header_item__PWJos"><a href="/url-notes">url-notes</a></div><div class="Header_separator__zF22U">|</div><div class="Header_item__PWJos"><a href="/url-notes/tags">tag</a></div><div class="Header_separator__zF22U">|</div><div class="Header_item__PWJos"><a href="/url-notes/tags">tag</a></div><div class="Header_separator__zF22U">|</div><div class="Header_item__PWJos"><span>ocaml</span></div></div><div class="page_content__fAQW6"><div class="page_previews__SpAnf"><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://dl.acm.org/doi/10.1007/11561347_18">Multi-stage programming with functors and monads | Proceedings of the 4th international conference on Generative Programming and Component Engineering</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/multi-stage%20programming">multi-stage programming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/functional%20programming">functional programming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/ocaml">ocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/metaocaml">metaocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/monads">monads</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/functors">functors</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/generative%20programming">generative programming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/metaprogramming">metaprogramming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/compilers">compilers</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/type%20systems">type systems</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/gaussian%20elimination">gaussian elimination</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/numerical%20algorithms">numerical algorithms</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/symbolic%20algorithms">symbolic algorithms</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/performance%20optimization">performance optimization</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/abstraction%20overhead">abstraction overhead</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/code%20generation">code generation</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/aspect-oriented%20programming">aspect-oriented programming</a></div><div class="ArticlePreview_summary__Zyb4E"><p>With Gaussian Elimination as a representative family of numerical and symbolic algorithms, we use multi-stage programming, monads and Ocaml&#x27;s advanced module system to demonstrate the complete elimination of the abstraction overhead while avoiding any inspection of the generated code. We parameterize our Gaussian Elimination code to a great extent (over domain, matrix representations, determinant tracking, pivoting policies, result types, etc) at no run-time cost. Because the resulting code is generated just right and not changed afterwards, we enjoy MetaOCaml&#x27;s guaranty that the generated code is well-typed. We further demonstrate that various abstraction parameters (aspects) can be made orthogonal and compositional, even in the presence of name-generation for temporaries and other bindings and “interleaving” of aspects. We also show how to encode some domain-specific knowledge so that “clearly wrong” compositions can be statically rejected by the compiler when processing the generator rather than the generated code.</p></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://okmij.org/ftp/ML/index.html#do-while">ML Programming</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/ml">ml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/ocaml">ocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/sml">sml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/metaocaml">metaocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/programming%20languages">programming languages</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/functional%20programming">functional programming</a></div><div class="ArticlePreview_summary__Zyb4E"><p>The index page for the portion of the web site related to OCaml, SML and MetaOCaml</p></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://okmij.org/ftp/ML/module-extensibility.html">Module Extensibility</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/ocaml">ocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/functional%20programming">functional programming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/programming%20languages">programming languages</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/compilers">compilers</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/module%20system">module system</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/modularity">modularity</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/extensibility">extensibility</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/separate%20compilation">separate compilation</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/type%20systems">type systems</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/abstract%20data%20types">abstract data types</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/software%20design">software design</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/linking">linking</a></div><div class="ArticlePreview_summary__Zyb4E"><ul>
<li><strong>Core Problem:</strong> OCaml&#x27;s separate compilation enforces a rigid one-to-one correspondence between an implementation file (<code>.ml</code>) and an interface file (<code>.mli</code>), which hinders two key aspects of module extensibility.</li>
<li><strong>Use Case 1: One Signature, Multiple Implementations</strong>
<ul>
<li><strong>Goal:</strong> Compile client code against a generic interface (<code>LA.mli</code>) and link it with different implementations (<code>EvalA.ml</code>, <code>PpA.ml</code>) without recompiling the client.</li>
<li><strong>Issue:</strong> The compiled client code (<code>ExA.cmo</code>) requires a specific module named <code>LA.cmo</code>, not just any module implementing the <code>LA</code> signature. The compiler also exhibits &quot;strange behavior&quot; by regenerating the interface file (<code>.cmi</code>) from the implementation, forcing client recompilation.</li>
<li><strong>Workaround:</strong> Use <code>ocamlc -c -o LA.cmo EvalA.ml</code> to compile an implementation under the expected name, or use symbolic links (<code>ln -s EvalA.ml LA.ml</code>) to achieve the same effect without modifying source. This still often requires recompiling the client or adds build complexity.</li>
</ul>
</li>
<li><strong>Use Case 2: Extending Implementations</strong>
<ul>
<li><strong>Goal:</strong> Non-destructively add new functions to an existing module (e.g., add <code>mul</code> to <code>EvalA</code> to create <code>EvalB</code>).</li>
<li><strong>Issue:</strong> The public interface (<code>EvalA.mli</code>) makes implementation types (like <code>repr</code>) abstract. The extension (<code>EvalB.ml</code>) needs the concrete type definition to implement new functions, but including <code>EvalA</code> only provides the abstract view.</li>
<li><strong>Workaround:</strong> Create a symbolic link (<code>ln -s EvalA.ml EvalA_impl.ml</code>). The extension then includes the <code>_impl</code> version, which has no corresponding <code>.mli</code> file, thereby exposing all implementation details and concrete types.</li>
</ul>
</li>
<li><strong>Proposals for OCaml:</strong>
<ul>
<li><strong>Short-term:</strong> When compiling <code>A.ml</code> to <code>B.cmo</code>, the compiler should use <code>B.mli</code> as the signature, behaving as if the source file were named <code>B.ml</code>.</li>
<li><strong>Long-term:</strong> Compiled modules should reference required <em>interfaces</em> rather than specific module names, decoupling implementations from signatures.</li>
</ul>
</li>
</ul></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://okmij.org/ftp/tagless-final/Compiler/index.html">Compiler</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/compiler">compiler</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/ocaml">ocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/tagless-final">tagless-final</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/computer%20science">computer science</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/programming%20language%20design">programming language design</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/x86-64">x86-64</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/assembly">assembly</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/incremental%20development">incremental development</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/build%20systems">build systems</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/type%20checking">type checking</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/code%20generation">code generation</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/parsing">parsing</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/education">education</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/course">course</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/algebraic%20effects">algebraic effects</a></div><div class="ArticlePreview_summary__Zyb4E"><ul>
<li><strong>Project:</strong> A course detailing the construction of a compiler for a &quot;Tiger-like&quot; procedural language, targeting x86-64 assembly.</li>
<li><strong>Implementation Language:</strong> OCaml.</li>
<li><strong>Core Architecture:</strong>
<ul>
<li><strong>Incremental Development:</strong> The compiler is built in iterative steps, starting with a minimal language (integer literals) and progressively adding features. Each step results in a complete, testable compiler for a language subset.</li>
<li><strong>Tagless-Final Style:</strong> Extensively used to structure the compiler as a stack of extensible domain-specific languages. This promotes reuse of type-checked and compiled components across development stages.</li>
<li><strong>Variable Handling:</strong> A notable feature is the treatment of variables and scope using a technique analogous to algebraic effects for analyzing usage and associating attributes.</li>
</ul>
</li>
<li><strong>Build System:</strong>
<ul>
<li>Utilizes a custom build tool (<code>build.ml</code>), an OCaml script, instead of <code>make</code>.</li>
<li>This tool is designed to handle the project&#x27;s specific incremental structure, where source files are spread across multiple directories corresponding to development steps. It provides an explicit manifest of all source files and their build order.</li>
</ul>
</li>
<li><strong>Course Content:</strong> Covers standard compiler topics, including parsing (<code>ocamllex</code>/<code>ocamlyacc</code>), type-checking, memory allocation, code generation for expressions, control flow, functions (nested, mutually-recursive), and state management.</li>
</ul></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://okmij.org/ftp/ML/MetaOCaml.html">MetaOCaml -- an OCaml dialect for multi-stage programming</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/programming%20languages">programming languages</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/ocaml">ocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/metaocaml">metaocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/multi-stage%20programming">multi-stage programming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/metaprogramming">metaprogramming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/generative%20programming">generative programming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/code%20generation">code generation</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/compilers">compilers</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/static%20typing">static typing</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/type%20safety">type safety</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/scope%20safety">scope safety</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/hygiene">hygiene</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/functional%20programming">functional programming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/run-time%20code%20specialization">run-time code specialization</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/domain-specific%20languages">domain-specific languages</a></div><div class="ArticlePreview_summary__Zyb4E"><ul>
<li>
<p><strong>Core Concept</strong>: MetaOCaml is a statically-typed, multi-stage programming language, implemented as a conservative extension of OCaml. It is designed for writing programs that generate specialized and optimized code at runtime.</p>
</li>
<li>
<p><strong>Key Language Constructs</strong>:</p>
<ul>
<li><strong>Code Type (<code>&#x27;a code</code>)</strong>: A type representing a fragment of a future-stage program that will produce a value of type <code>&#x27;a</code>.</li>
<li><strong>Brackets (<code>.&lt;e&gt;.</code>)</strong>: &quot;Quotes&quot; an expression <code>e</code>, deferring its computation to a later stage and creating a value of type <code>code</code>.</li>
<li><strong>Escape (<code>.~e</code>)</strong>: Used within brackets to splice the result of a present-stage computation (which must be of a <code>code</code> type) into the generated code.</li>
</ul>
</li>
<li>
<p><strong>Static Guarantees</strong>:</p>
<ul>
<li><strong>Type Safety</strong>: A well-typed MetaOCaml program is guaranteed to generate well-typed OCaml code. Type errors are caught in the generator, not the generated code.</li>
<li><strong>Scope Safety (Hygiene)</strong>: Lexical scope is preserved. A dynamic &quot;scope extrusion&quot; check aborts generation if a variable would escape its binder, providing a strong guarantee of well-scoped code. This replaces the older, less comprehensive static &quot;environment classifier&quot; system.</li>
</ul>
</li>
<li>
<p><strong>Code Execution &amp; Offshoring</strong>:</p>
<ul>
<li>Generated code can be compiled (to bytecode or native code via <code>Runcode.run</code>) and dynamically linked back into the running program, enabling run-time code specialization.</li>
<li><strong>Offshoring</strong>: A subset of the generated OCaml code can be translated into a simple imperative intermediate language, which can then be transcribed to targets like C, LLVM, or OpenCL.</li>
</ul>
</li>
<li>
<p><strong>Advanced Generative Features</strong>:</p>
<ul>
<li><strong>Let-Insertion (<code>genlet</code>)</strong>: A primitive to control evaluation and code motion by explicitly creating <code>let</code>-bindings in the generated code. The insertion point is automatically determined to preserve scoping, but can be manually controlled with <code>locus</code>.</li>
<li><strong>Recursive Definition Generation (<code>mkgenlet</code>)</strong>: Generates <code>let rec</code> bindings for a statically unknown number of mutually recursive functions, useful for specializing recursive functions or generating state machines.</li>
<li><strong>First-Class Patterns (<code>make_match</code>)</strong>: Dynamically constructs <code>match</code> expressions from a list of <code>pat_code</code> values (function literals), enabling the generation of pattern matches with a variable number of clauses.</li>
<li><strong>Cross-Stage Persistence (CSP)</strong>: Allows values from the generator stage to be used in the generated code. Global identifiers are treated as library references. Local identifiers of known serializable types are copied by value; others are handled by reference via closures.</li>
</ul>
</li>
</ul></div></div><div class="ArticlePreview_ArticlePreview__59E_4"><div class="ArticlePreview_title__Snpua"><a target="_blank" href="https://okmij.org/ftp/ML/index.html#dynvar">ML Programming</a></div><div class="ArticlePreview_tags__y8wnE"><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/programming%20languages">programming languages</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/functional%20programming">functional programming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/ocaml">ocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/sml">sml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/standard%20ml">standard ml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/metaocaml">metaocaml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/ml">ml</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/meta-programming">meta-programming</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/computer%20science">computer science</a><a class="ArticlePreview_tag___oIyn" href="/url-notes/tag/programming">programming</a></div><div class="ArticlePreview_summary__Zyb4E"><p>The index page for the portion of the web site related to OCaml, SML and MetaOCaml</p></div></div></div></div></div><!--$--><!--/$--><script src="/url-notes/_next/static/chunks/webpack-b3777c3e67e20b2e.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n5:I[9665,[],\"OutletBoundary\"]\n7:I[4911,[],\"AsyncMetadataOutlet\"]\n9:I[9665,[],\"ViewportBoundary\"]\nb:I[9665,[],\"MetadataBoundary\"]\nc:\"$Sreact.suspense\"\ne:I[8393,[],\"\"]\n:HL[\"/url-notes/_next/static/css/f03c873af434c7c6.css\",\"style\"]\n:HL[\"/url-notes/_next/static/css/0e5ea1ea0183b412.css\",\"style\"]\n:HL[\"/url-notes/_next/static/css/a9d1307f18e49070.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"HHf8jOZ8wqjLnhweFigGn\",\"p\":\"/url-notes\",\"c\":[\"\",\"tag\",\"ocaml\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"tag\",{\"children\":[[\"tag\",\"ocaml\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/url-notes/_next/static/css/f03c873af434c7c6.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"tag\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"tag\",\"ocaml\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/url-notes/_next/static/css/0e5ea1ea0183b412.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/url-notes/_next/static/css/a9d1307f18e49070.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$L5\",null,{\"children\":[\"$L6\",[\"$\",\"$L7\",null,{\"promise\":\"$@8\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$L9\",null,{\"children\":\"$La\"}],null],[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$c\",null,{\"fallback\":null,\"children\":\"$Ld\"}]}]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$e\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n6:null\n"])</script><script>self.__next_f.push([1,"f:I[8175,[],\"IconMark\"]\n8:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"url-notes | tag | ocaml\"}],[\"$\",\"link\",\"1\",{\"rel\":\"icon\",\"href\":\"/url-notes/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"256x256\"}],[\"$\",\"$Lf\",\"2\",{}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"d:\"$8:metadata\"\n"])</script><script>self.__next_f.push([1,"10:I[6874,[\"874\",\"static/chunks/874-437a265a67d6cfee.js\",\"296\",\"static/chunks/app/tag/%5Btag%5D/page-42d05b4590119831.js\"],\"\"]\n11:T411,"])</script><script>self.__next_f.push([1,"With Gaussian Elimination as a representative family of numerical and symbolic algorithms, we use multi-stage programming, monads and Ocaml's advanced module system to demonstrate the complete elimination of the abstraction overhead while avoiding any inspection of the generated code. We parameterize our Gaussian Elimination code to a great extent (over domain, matrix representations, determinant tracking, pivoting policies, result types, etc) at no run-time cost. Because the resulting code is generated just right and not changed afterwards, we enjoy MetaOCaml's guaranty that the generated code is well-typed. We further demonstrate that various abstraction parameters (aspects) can be made orthogonal and compositional, even in the presence of name-generation for temporaries and other bindings and “interleaving” of aspects. We also show how to encode some domain-specific knowledge so that “clearly wrong” compositions can be statically rejected by the compiler when processing the generator rather than the generated code."])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"$undefined\",\"children\":[[\"$\",\"div\",null,{\"className\":\"Header_Header__VDN4T\",\"children\":[[\"$\",\"div\",null,{\"className\":\"Header_item__PWJos\",\"children\":[\"$\",\"$L10\",null,{\"href\":\"/\",\"children\":\"url-notes\"}]}],[[[\"$\",\"div\",\"separator-0\",{\"className\":\"Header_separator__zF22U\",\"children\":\"|\"}],[\"$\",\"div\",\"item-0\",{\"className\":\"Header_item__PWJos\",\"children\":[\"$\",\"$L10\",\"0\",{\"href\":\"/tags\",\"children\":\"tag\"}]}]],[[\"$\",\"div\",\"separator-1\",{\"className\":\"Header_separator__zF22U\",\"children\":\"|\"}],[\"$\",\"div\",\"item-1\",{\"className\":\"Header_item__PWJos\",\"children\":[\"$\",\"$L10\",\"1\",{\"href\":\"/tags\",\"children\":\"tag\"}]}]],[[\"$\",\"div\",\"separator-2\",{\"className\":\"Header_separator__zF22U\",\"children\":\"|\"}],[\"$\",\"div\",\"item-2\",{\"className\":\"Header_item__PWJos\",\"children\":[\"$\",\"span\",\"2\",{\"children\":\"ocaml\"}]}]]]]}],[\"$\",\"div\",null,{\"className\":\"page_content__fAQW6\",\"children\":[\"$\",\"div\",null,{\"className\":\"page_previews__SpAnf\",\"children\":[[\"$\",\"div\",\"0\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$L10\",null,{\"href\":\"https://dl.acm.org/doi/10.1007/11561347_18\",\"target\":\"_blank\",\"children\":\"Multi-stage programming with functors and monads | Proceedings of the 4th international conference on Generative Programming and Component Engineering\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$L10\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/multi-stage%20programming\",\"children\":\"multi-stage programming\"}],[\"$\",\"$L10\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/functional%20programming\",\"children\":\"functional programming\"}],[\"$\",\"$L10\",\"2\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/ocaml\",\"children\":\"ocaml\"}],[\"$\",\"$L10\",\"3\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/metaocaml\",\"children\":\"metaocaml\"}],[\"$\",\"$L10\",\"4\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/monads\",\"children\":\"monads\"}],[\"$\",\"$L10\",\"5\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/functors\",\"children\":\"functors\"}],[\"$\",\"$L10\",\"6\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/generative%20programming\",\"children\":\"generative programming\"}],[\"$\",\"$L10\",\"7\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/metaprogramming\",\"children\":\"metaprogramming\"}],[\"$\",\"$L10\",\"8\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/compilers\",\"children\":\"compilers\"}],[\"$\",\"$L10\",\"9\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/type%20systems\",\"children\":\"type systems\"}],[\"$\",\"$L10\",\"10\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/gaussian%20elimination\",\"children\":\"gaussian elimination\"}],[\"$\",\"$L10\",\"11\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/numerical%20algorithms\",\"children\":\"numerical algorithms\"}],[\"$\",\"$L10\",\"12\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/symbolic%20algorithms\",\"children\":\"symbolic algorithms\"}],[\"$\",\"$L10\",\"13\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/performance%20optimization\",\"children\":\"performance optimization\"}],[\"$\",\"$L10\",\"14\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/abstraction%20overhead\",\"children\":\"abstraction overhead\"}],[\"$\",\"$L10\",\"15\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/code%20generation\",\"children\":\"code generation\"}],[\"$\",\"$L10\",\"16\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/aspect-oriented%20programming\",\"children\":\"aspect-oriented programming\"}]]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"$11\"}]]}]]}],\"$L12\",\"$L13\",\"$L14\",\"$L15\",\"$L16\"]}]}]]}]\n"])</script><script>self.__next_f.push([1,"12:[\"$\",\"div\",\"1\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$L10\",null,{\"href\":\"https://okmij.org/ftp/ML/index.html#do-while\",\"target\":\"_blank\",\"children\":\"ML Programming\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$L10\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/ml\",\"children\":\"ml\"}],[\"$\",\"$L10\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/ocaml\",\"children\":\"ocaml\"}],[\"$\",\"$L10\",\"2\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/sml\",\"children\":\"sml\"}],[\"$\",\"$L10\",\"3\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/metaocaml\",\"children\":\"metaocaml\"}],[\"$\",\"$L10\",\"4\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/programming%20languages\",\"children\":\"programming languages\"}],[\"$\",\"$L10\",\"5\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/functional%20programming\",\"children\":\"functional programming\"}]]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"The index page for the portion of the web site related to OCaml, SML and MetaOCaml\"}]]}]]}]\n"])</script><script>self.__next_f.push([1,"13:[\"$\",\"div\",\"2\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$L10\",null,{\"href\":\"https://okmij.org/ftp/ML/module-extensibility.html\",\"target\":\"_blank\",\"children\":\"Module Extensibility\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$L10\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/ocaml\",\"children\":\"ocaml\"}],[\"$\",\"$L10\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/functional%20programming\",\"children\":\"functional programming\"}],[\"$\",\"$L10\",\"2\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/programming%20languages\",\"children\":\"programming languages\"}],[\"$\",\"$L10\",\"3\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/compilers\",\"children\":\"compilers\"}],[\"$\",\"$L10\",\"4\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/module%20system\",\"children\":\"module system\"}],[\"$\",\"$L10\",\"5\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/modularity\",\"children\":\"modularity\"}],[\"$\",\"$L10\",\"6\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/extensibility\",\"children\":\"extensibility\"}],[\"$\",\"$L10\",\"7\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/separate%20compilation\",\"children\":\"separate compilation\"}],[\"$\",\"$L10\",\"8\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/type%20systems\",\"children\":\"type systems\"}],[\"$\",\"$L10\",\"9\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/abstract%20data%20types\",\"children\":\"abstract data types\"}],[\"$\",\"$L10\",\"10\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/software%20design\",\"children\":\"software design\"}],[\"$\",\"$L10\",\"11\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/linking\",\"children\":\"linking\"}]]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Core Problem:\"}],\" OCaml's separate compilation enforces a rigid one-to-one correspondence between an implementation file (\",[\"$\",\"code\",\"code-0\",{\"children\":\".ml\"}],\") and an interface file (\",[\"$\",\"code\",\"code-1\",{\"children\":\".mli\"}],\"), which hinders two key aspects of module extensibility.\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Use Case 1: One Signature, Multiple Implementations\"}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Goal:\"}],\" Compile client code against a generic interface (\",[\"$\",\"code\",\"code-0\",{\"children\":\"LA.mli\"}],\") and link it with different implementations (\",[\"$\",\"code\",\"code-1\",{\"children\":\"EvalA.ml\"}],\", \",[\"$\",\"code\",\"code-2\",{\"children\":\"PpA.ml\"}],\") without recompiling the client.\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Issue:\"}],\" The compiled client code (\",[\"$\",\"code\",\"code-0\",{\"children\":\"ExA.cmo\"}],\") requires a specific module named \",[\"$\",\"code\",\"code-1\",{\"children\":\"LA.cmo\"}],\", not just any module implementing the \",[\"$\",\"code\",\"code-2\",{\"children\":\"LA\"}],\" signature. The compiler also exhibits \\\"strange behavior\\\" by regenerating the interface file (\",[\"$\",\"code\",\"code-3\",{\"children\":\".cmi\"}],\") from the implementation, forcing client recompilation.\"]}],\"\\n\",[\"$\",\"li\",\"li-2\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Workaround:\"}],\" Use \",[\"$\",\"code\",\"code-0\",{\"children\":\"ocamlc -c -o LA.cmo EvalA.ml\"}],\" to compile an implementation under the expected name, or use symbolic links (\",[\"$\",\"code\",\"code-1\",{\"children\":\"ln -s EvalA.ml LA.ml\"}],\") to achieve the same effect without modifying source. This still often requires recompiling the client or adds build complexity.\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",\"li-2\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Use Case 2: Extending Implementations\"}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Goal:\"}],\" Non-destructively add new functions to an existing module (e.g., add \",[\"$\",\"code\",\"code-0\",{\"children\":\"mul\"}],\" to \",[\"$\",\"code\",\"code-1\",{\"children\":\"EvalA\"}],\" to create \",[\"$\",\"code\",\"code-2\",{\"children\":\"EvalB\"}],\").\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[\"$L17\",\" The public interface (\",\"$L18\",\") makes implementation types (like \",\"$L19\",\") abstract. The extension (\",\"$L1a\",\") needs the concrete type definition to implement new functions, but including \",\"$L1b\",\" only provides the abstract view.\"]}],\"\\n\",\"$L1c\",\"\\n\"]}],\"\\n\"]}],\"\\n\",\"$L1d\",\"\\n\"]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"14:[\"$\",\"div\",\"3\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$L10\",null,{\"href\":\"https://okmij.org/ftp/tagless-final/Compiler/index.html\",\"target\":\"_blank\",\"children\":\"Compiler\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$L10\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/compiler\",\"children\":\"compiler\"}],[\"$\",\"$L10\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/ocaml\",\"children\":\"ocaml\"}],[\"$\",\"$L10\",\"2\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/tagless-final\",\"children\":\"tagless-final\"}],[\"$\",\"$L10\",\"3\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/computer%20science\",\"children\":\"computer science\"}],[\"$\",\"$L10\",\"4\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/programming%20language%20design\",\"children\":\"programming language design\"}],[\"$\",\"$L10\",\"5\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/x86-64\",\"children\":\"x86-64\"}],[\"$\",\"$L10\",\"6\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/assembly\",\"children\":\"assembly\"}],[\"$\",\"$L10\",\"7\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/incremental%20development\",\"children\":\"incremental development\"}],[\"$\",\"$L10\",\"8\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/build%20systems\",\"children\":\"build systems\"}],[\"$\",\"$L10\",\"9\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/type%20checking\",\"children\":\"type checking\"}],[\"$\",\"$L10\",\"10\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/code%20generation\",\"children\":\"code generation\"}],[\"$\",\"$L10\",\"11\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/parsing\",\"children\":\"parsing\"}],[\"$\",\"$L10\",\"12\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/education\",\"children\":\"education\"}],[\"$\",\"$L10\",\"13\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/course\",\"children\":\"course\"}],[\"$\",\"$L10\",\"14\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/algebraic%20effects\",\"children\":\"algebraic effects\"}]]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Project:\"}],\" A course detailing the construction of a compiler for a \\\"Tiger-like\\\" procedural language, targeting x86-64 assembly.\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Implementation Language:\"}],\" OCaml.\"]}],\"\\n\",[\"$\",\"li\",\"li-2\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Core Architecture:\"}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Incremental Development:\"}],\" The compiler is built in iterative steps, starting with a minimal language (integer literals) and progressively adding features. Each step results in a complete, testable compiler for a language subset.\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Tagless-Final Style:\"}],\" Extensively used to structure the compiler as a stack of extensible domain-specific languages. This promotes reuse of type-checked and compiled components across development stages.\"]}],\"\\n\",[\"$\",\"li\",\"li-2\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Variable Handling:\"}],\" A notable feature is the treatment of variables and scope using a technique analogous to algebraic effects for analyzing usage and associating attributes.\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",\"li-3\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Build System:\"}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[\"Utilizes a custom build tool (\",[\"$\",\"code\",\"code-0\",{\"children\":\"build.ml\"}],\"), an OCaml script, instead of \",[\"$\",\"code\",\"code-1\",{\"children\":\"make\"}],\".\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":\"This tool is designed to handle the project's specific incremental structure, where source files are spread across multiple directories corresponding to development steps. It provides an explicit manifest of all source files and their build order.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",\"li-4\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Course Content:\"}],\" Covers standard compiler topics, including parsing (\",\"$L1e\",\"/\",\"$L1f\",\"), type-checking, memory allocation, code generation for expressions, control flow, functions (nested, mutually-recursive), and state management.\"]}],\"\\n\"]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"15:[\"$\",\"div\",\"4\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$L10\",null,{\"href\":\"https://okmij.org/ftp/ML/MetaOCaml.html\",\"target\":\"_blank\",\"children\":\"MetaOCaml -- an OCaml dialect for multi-stage programming\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$L10\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/programming%20languages\",\"children\":\"programming languages\"}],[\"$\",\"$L10\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/ocaml\",\"children\":\"ocaml\"}],[\"$\",\"$L10\",\"2\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/metaocaml\",\"children\":\"metaocaml\"}],[\"$\",\"$L10\",\"3\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/multi-stage%20programming\",\"children\":\"multi-stage programming\"}],[\"$\",\"$L10\",\"4\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/metaprogramming\",\"children\":\"metaprogramming\"}],[\"$\",\"$L10\",\"5\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/generative%20programming\",\"children\":\"generative programming\"}],[\"$\",\"$L10\",\"6\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/code%20generation\",\"children\":\"code generation\"}],[\"$\",\"$L10\",\"7\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/compilers\",\"children\":\"compilers\"}],[\"$\",\"$L10\",\"8\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/static%20typing\",\"children\":\"static typing\"}],[\"$\",\"$L10\",\"9\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/type%20safety\",\"children\":\"type safety\"}],[\"$\",\"$L10\",\"10\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/scope%20safety\",\"children\":\"scope safety\"}],[\"$\",\"$L10\",\"11\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/hygiene\",\"children\":\"hygiene\"}],[\"$\",\"$L10\",\"12\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/functional%20programming\",\"children\":\"functional programming\"}],[\"$\",\"$L10\",\"13\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/run-time%20code%20specialization\",\"children\":\"run-time code specialization\"}],[\"$\",\"$L10\",\"14\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/domain-specific%20languages\",\"children\":\"domain-specific languages\"}]]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[\"\\n\",[\"$\",\"p\",\"p-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Core Concept\"}],\": MetaOCaml is a statically-typed, multi-stage programming language, implemented as a conservative extension of OCaml. It is designed for writing programs that generate specialized and optimized code at runtime.\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[\"\\n\",[\"$\",\"p\",\"p-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Key Language Constructs\"}],\":\"]}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":[\"Code Type (\",[\"$\",\"code\",\"code-0\",{\"children\":\"'a code\"}],\")\"]}],\": A type representing a fragment of a future-stage program that will produce a value of type \",[\"$\",\"code\",\"code-0\",{\"children\":\"'a\"}],\".\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":[\"Brackets (\",[\"$\",\"code\",\"code-0\",{\"children\":\".\u003ce\u003e.\"}],\")\"]}],\": \\\"Quotes\\\" an expression \",[\"$\",\"code\",\"code-0\",{\"children\":\"e\"}],\", deferring its computation to a later stage and creating a value of type \",[\"$\",\"code\",\"code-1\",{\"children\":\"code\"}],\".\"]}],\"\\n\",[\"$\",\"li\",\"li-2\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":[\"Escape (\",[\"$\",\"code\",\"code-0\",{\"children\":\".~e\"}],\")\"]}],\": Used within brackets to splice the result of a present-stage computation (which must be of a \",[\"$\",\"code\",\"code-0\",{\"children\":\"code\"}],\" type) into the generated code.\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",\"li-2\",{\"children\":[\"\\n\",[\"$\",\"p\",\"p-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Static Guarantees\"}],\":\"]}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Type Safety\"}],\": A well-typed MetaOCaml program is guaranteed to generate well-typed OCaml code. Type errors are caught in the generator, not the generated code.\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Scope Safety (Hygiene)\"}],\": Lexical scope is preserved. A dynamic \\\"scope extrusion\\\" check aborts generation if a variable would escape its binder, providing a strong guarantee of well-scoped code. This replaces the older, less comprehensive static \\\"environment classifier\\\" system.\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",\"$L20\",\"\\n\",\"$L21\",\"\\n\"]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"16:[\"$\",\"div\",\"5\",{\"className\":\"ArticlePreview_ArticlePreview__59E_4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ArticlePreview_title__Snpua\",\"children\":[\"$\",\"$L10\",null,{\"href\":\"https://okmij.org/ftp/ML/index.html#dynvar\",\"target\":\"_blank\",\"children\":\"ML Programming\"}]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_tags__y8wnE\",\"children\":[[\"$\",\"$L10\",\"0\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/programming%20languages\",\"children\":\"programming languages\"}],[\"$\",\"$L10\",\"1\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/functional%20programming\",\"children\":\"functional programming\"}],[\"$\",\"$L10\",\"2\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/ocaml\",\"children\":\"ocaml\"}],[\"$\",\"$L10\",\"3\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/sml\",\"children\":\"sml\"}],[\"$\",\"$L10\",\"4\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/standard%20ml\",\"children\":\"standard ml\"}],[\"$\",\"$L10\",\"5\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/metaocaml\",\"children\":\"metaocaml\"}],[\"$\",\"$L10\",\"6\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/ml\",\"children\":\"ml\"}],[\"$\",\"$L10\",\"7\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/meta-programming\",\"children\":\"meta-programming\"}],[\"$\",\"$L10\",\"8\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/computer%20science\",\"children\":\"computer science\"}],[\"$\",\"$L10\",\"9\",{\"className\":\"ArticlePreview_tag___oIyn\",\"href\":\"/tag/programming\",\"children\":\"programming\"}]]}],[\"$\",\"div\",null,{\"className\":\"ArticlePreview_summary__Zyb4E\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"The index page for the portion of the web site related to OCaml, SML and MetaOCaml\"}]]}]]}]\n"])</script><script>self.__next_f.push([1,"17:[\"$\",\"strong\",\"strong-0\",{\"children\":\"Issue:\"}]\n18:[\"$\",\"code\",\"code-0\",{\"children\":\"EvalA.mli\"}]\n19:[\"$\",\"code\",\"code-1\",{\"children\":\"repr\"}]\n1a:[\"$\",\"code\",\"code-2\",{\"children\":\"EvalB.ml\"}]\n1b:[\"$\",\"code\",\"code-3\",{\"children\":\"EvalA\"}]\n1c:[\"$\",\"li\",\"li-2\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Workaround:\"}],\" Create a symbolic link (\",[\"$\",\"code\",\"code-0\",{\"children\":\"ln -s EvalA.ml EvalA_impl.ml\"}],\"). The extension then includes the \",[\"$\",\"code\",\"code-1\",{\"children\":\"_impl\"}],\" version, which has no corresponding \",[\"$\",\"code\",\"code-2\",{\"children\":\".mli\"}],\" file, thereby exposing all implementation details and concrete types.\"]}]\n"])</script><script>self.__next_f.push([1,"1d:[\"$\",\"li\",\"li-3\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Proposals for OCaml:\"}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Short-term:\"}],\" When compiling \",[\"$\",\"code\",\"code-0\",{\"children\":\"A.ml\"}],\" to \",[\"$\",\"code\",\"code-1\",{\"children\":\"B.cmo\"}],\", the compiler should use \",[\"$\",\"code\",\"code-2\",{\"children\":\"B.mli\"}],\" as the signature, behaving as if the source file were named \",[\"$\",\"code\",\"code-3\",{\"children\":\"B.ml\"}],\".\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Long-term:\"}],\" Compiled modules should reference required \",[\"$\",\"em\",\"em-0\",{\"children\":\"interfaces\"}],\" rather than specific module names, decoupling implementations from signatures.\"]}],\"\\n\"]}],\"\\n\"]}]\n"])</script><script>self.__next_f.push([1,"1e:[\"$\",\"code\",\"code-0\",{\"children\":\"ocamllex\"}]\n1f:[\"$\",\"code\",\"code-1\",{\"children\":\"ocamlyacc\"}]\n"])</script><script>self.__next_f.push([1,"20:[\"$\",\"li\",\"li-3\",{\"children\":[\"\\n\",[\"$\",\"p\",\"p-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Code Execution \u0026 Offshoring\"}],\":\"]}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[\"Generated code can be compiled (to bytecode or native code via \",[\"$\",\"code\",\"code-0\",{\"children\":\"Runcode.run\"}],\") and dynamically linked back into the running program, enabling run-time code specialization.\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Offshoring\"}],\": A subset of the generated OCaml code can be translated into a simple imperative intermediate language, which can then be transcribed to targets like C, LLVM, or OpenCL.\"]}],\"\\n\"]}],\"\\n\"]}]\n"])</script><script>self.__next_f.push([1,"21:[\"$\",\"li\",\"li-4\",{\"children\":[\"\\n\",[\"$\",\"p\",\"p-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Advanced Generative Features\"}],\":\"]}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":[\"Let-Insertion (\",[\"$\",\"code\",\"code-0\",{\"children\":\"genlet\"}],\")\"]}],\": A primitive to control evaluation and code motion by explicitly creating \",[\"$\",\"code\",\"code-0\",{\"children\":\"let\"}],\"-bindings in the generated code. The insertion point is automatically determined to preserve scoping, but can be manually controlled with \",[\"$\",\"code\",\"code-1\",{\"children\":\"locus\"}],\".\"]}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":[\"Recursive Definition Generation (\",[\"$\",\"code\",\"code-0\",{\"children\":\"mkgenlet\"}],\")\"]}],\": Generates \",[\"$\",\"code\",\"code-0\",{\"children\":\"let rec\"}],\" bindings for a statically unknown number of mutually recursive functions, useful for specializing recursive functions or generating state machines.\"]}],\"\\n\",[\"$\",\"li\",\"li-2\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":[\"First-Class Patterns (\",[\"$\",\"code\",\"code-0\",{\"children\":\"make_match\"}],\")\"]}],\": Dynamically constructs \",[\"$\",\"code\",\"code-0\",{\"children\":\"match\"}],\" expressions from a list of \",[\"$\",\"code\",\"code-1\",{\"children\":\"pat_code\"}],\" values (function literals), enabling the generation of pattern matches with a variable number of clauses.\"]}],\"\\n\",[\"$\",\"li\",\"li-3\",{\"children\":[[\"$\",\"strong\",\"strong-0\",{\"children\":\"Cross-Stage Persistence (CSP)\"}],\": Allows values from the generator stage to be used in the generated code. Global identifiers are treated as library references. Local identifiers of known serializable types are copied by value; others are handled by reference via closures.\"]}],\"\\n\"]}],\"\\n\"]}]\n"])</script></body></html>